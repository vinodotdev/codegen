
// A list of ports and their type signatures.
#[must_use]
#[cfg(all(feature="provider", any(feature = "native", feature = "wasm")))]
pub fn outputs_list() -> std::collections::HashMap<String, TypeSignature> {
  let mut map = std::collections::HashMap::new();
  {{#each .}}
    map.insert("{{@key}}".to_owned(),{{> type-signature .}});
  {{/each}}
  map
}

// A list of output ports and their associated stream sender implementations.
#[derive(Debug)]
#[cfg_attr(all(feature = "provider", feature="native"), derive(Default))]
#[cfg(feature = "provider")]
pub struct OutputPorts {
  {{#each .}}
    pub {{snakeCase @key}}: {{pascalCase @key}}PortSender,
  {{/each}}
}

// Definition and implementation of each port's sender.
{{#each .}}
#[derive(Debug)]
#[cfg(feature = "provider")]
pub struct {{pascalCase @key}}PortSender {
    #[cfg(feature = "native")]
    port: PortChannel,
    #[cfg(feature = "wasm")]
    id: u32,
}

#[cfg(all(feature = "provider", feature="native"))]
impl Default for {{pascalCase @key}}PortSender {
    fn default() -> Self {
        Self {
            port: PortChannel::new("{{@key}}"),
        }
    }
}

// Native sender implementation
#[cfg(all(feature = "provider", feature="native"))]
impl PortSender for {{pascalCase @key}}PortSender {
    fn get_port(&self) -> Result<&PortChannel, ProviderError> {
      if self.port.is_closed() {
        Err(ProviderError::SendChannelClosed)
      } else {
        Ok(&self.port)
      }
    }

    fn get_port_name(&self) -> &str {
      &self.port.name
    }
}

// WASM sender implementation
#[cfg(all(feature = "provider", feature="wasm"))]
impl PortSender for {{pascalCase @key}}PortSender {
  type PayloadType = {{> expand-type .}};
  fn get_name(&self) -> String {
    "{{@key}}".to_string()
  }
  fn get_id(&self) -> u32 {
    self.id
  }
}
{{/each}}


#[must_use]
#[cfg(all(feature = "provider", feature="native"))]
pub fn get_outputs() -> (OutputPorts, TransportStream) {
    let mut outputs = OutputPorts::default();
    let mut ports = vec![
    {{#each .}}
    &mut outputs.{{snakeCase @key}}.port,
    {{/each}}
    ];
    let stream = PortChannel::merge_all(&mut ports);
    (outputs, stream)
}

#[cfg(all(feature = "provider", feature="wasm"))]
fn get_outputs(id:u32) -> OutputPorts {
  OutputPorts {
  {{#each .}}
    {{snakeCase @key}}: {{pascalCase @key}}PortSender { id },
  {{/each}}
  }
}

#[cfg(all(feature = "guest"))]
#[allow(missing_debug_implementations)]
pub struct Outputs {
  packets: ProviderOutput
}

#[cfg(all(feature = "native", feature = "guest"))]
impl Outputs {
  {{#each .}}
    pub async fn {{snakeCase @key}}(&mut self)-> Result<PortOutput<{{> expand-type . }}>, ProviderError> {
      let packets = self.packets.drain_port("{{@key}}").await;
      Ok(PortOutput::new("{{@key}}".to_owned(), packets))
    }
  {{/each}}
}

#[cfg(all(feature = "wasm", feature = "guest"))]
impl Outputs {
  {{#each .}}
    pub fn {{snakeCase @key}}(&mut self)-> Result<PortOutput, ComponentError> {
      let packets = self.packets.drain_port("{{@key}}")?;
      Ok(PortOutput::new("{{@key}}".to_owned(), packets))
    }
  {{/each}}
}

#[cfg(all(feature = "wasm", feature = "guest"))]
impl From<ProviderOutput> for Outputs {
  fn from(packets: ProviderOutput) -> Self {
    Self{packets}
  }
}


#[cfg(all(feature = "native", feature = "guest"))]
impl From<ProviderOutput> for Outputs {
  fn from(output: ProviderOutput) -> Self {
    Self { packets: output }
  }
}

#[cfg(all(feature = "native", feature = "guest"))]
impl From<BoxedTransportStream> for Outputs {
  fn from(stream: BoxedTransportStream) -> Self {
    Self{packets: ProviderOutput::new(stream)}
  }
}