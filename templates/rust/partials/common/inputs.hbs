

#[cfg(all(feature = "native", not(feature = "wasm")))]
pub fn populate_inputs(mut payload: TransportMap) -> Result<Inputs, TransportError> {
  Ok(Inputs {
    {{#each . }}
      {{snakeCase @key}}: payload.consume("{{@key}}")?,
    {{/each}}
  })
}

#[cfg(all(feature = "wasm", not(feature = "native")))]
fn populate_inputs(payload: &IncomingPayload) -> Result<Inputs, WasmError> {
  Ok(Inputs {
    {{#each . }}
    {{snakeCase @key}}: deserialize(payload.get("{{@key}}")?)?,
    {{/each}}
  })
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
pub struct Inputs {
{{#each . }}
  #[serde(rename = "{{@key}}")]
  pub {{snakeCase @key}}: {{> expand-type .}},
{{/each}}
}

#[cfg(all(feature = "guest", any(feature = "native", feature = "wasm")))]
impl From<Inputs> for TransportMap {
  fn from(inputs: Inputs) -> TransportMap {
    let mut map = TransportMap::new();
    {{#each . }}
      map.insert("{{snakeCase @key}}", MessageTransport::success(&inputs.{{snakeCase @key}}));
    {{/each}}
    map
  }
}

#[must_use]
#[cfg(all(feature="provider", feature = "native"))]
pub fn inputs_list() -> std::collections::HashMap<String, TypeSignature> {
  let mut map = std::collections::HashMap::new();
  {{#each .}}
    map.insert("{{@key}}".to_owned(),{{> type-signature .}});
  {{/each}}
  map
}